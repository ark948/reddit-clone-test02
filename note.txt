1. setting up
    base fastapi application structure
2. setting up environment variables
    (database needs asyncpg)
    > pip install asyncpg
    (if intent to use dotenv)> pip install python-dotenv (WARNING: using 'pip install dotenv' will result in failure)
    (if intent to use pydantic_settings - recommended)> pip install pydantic_settings
3. setting up database
    creating connection and session
    > psql --username=postgres (password: 1234)
    creating database session dependency
    connecting main app instance to database initializer
    adding alembic and database migration:
    > pip install alembic
    > alembic init -t async <migrationFolderName>
    1. import models in env.py of alembic folder (all models separatly)
    2. import SQLModel from sqlmodel
    3. set sqlalchemy url option config in env.py (use project's Config instance)
    4. specify target metadata
    5. import sqlmodel in script.py.mako
    6. run> alembic revision --autogenerate -m "message"
    7. apply migration> alembic upgrade head
4. setting up authentication
    beginning with user model
    to add password hashing, following packages must be isntalled:
    > pip install passlib, bcrypt
    authentication process:
        hash user's info
        put them in a token
        create login route
        succeessful login = create and send token
        succeessful logout = block token

        auth commit 01:
            utils -> create token, decode_token
            schemas -> UserLoginSchema
            routes -> login route
            config -> added jwt secret and jwt algorithm
        auth commit 02:
            tokens -> AccessTokenBearer
            routes -> user_profile
        auth commit 03:
            tokens -> separating access token and refresh token
        auth commit 04:
            tokens -> TokenBearer updated methods
            routes -> added refresh token route
5. setting up redis
    (redis will be used to hold blocklisted tokens)
    (expired tokens will be added to blocklist upon user logout)
    (aioredis is deprecated - use redis-py)
    1. redis docker image needs to be downloaded and ran
    2. then, initialize a redis client in src/sections/redis.py (pip install redis)
    use this command to run redis on docker:
    > docker run -p 6379:6379 -it redis/redis-stack:latest
    (our first redis setup may be trivial, this will be improved later)

    AUTH (commit 05) (needs rechecking - blocked tokens should not be valid anymore)
    logout route is now added (token will be added to redis blocklist)

6. adding role-based access control (RBAC)
    1. add role field to User model (was already added)
    2. add get_current_user and RoleChecker class to authentication (new file roles.py)
    3. crud and service needs to be updated (add role to user creation)
    4. after creating get_current_user, all routes can be updated (from Depending on tokens to Depending on get_current_user)
    5. also session is no longer required for these routes (since get_current_user already has it)


7. adding custom errors (error handling)
    1. we'll add custom errros to src/sections/errors.py
    2. then a function that will take a custom exception and allows fastapi to raise it as a response
    (without it fastapi does not know how to return a custom exception, afterall they are not responses, they are python exceptions)
    3. after creating exceptions and exception handler, we need to associate our exceptions with fastapi
    (for that, we'll make another function that will take our app instance, and registers all errors on it)
    4. we will also add custom error handler for 500 internal server error and for sqlalchemy error
    5. we must call our error register function in main.py
    6. finally we need to modify entire project to return our custom errors (in a separate commit)
    list of modules that will have custom errors:
    auth -> tokens.py
    auth -> roles.py
    auth -> routes.py

8. adding middlewares
    (this is not a required step, only use custom middlewares if actually needed)
    e.g. CORSMiddleware is required to setup a simple mail fucntionality
    (we may install fastapi-mail aswell)
    
9. adding email verification
    1. pip install itsdangerous
    2. begin by creating a way to safely pass tokens to unsafe environments, such as user's email address (in auth > utils.py)
    (many mail stuff are skipped)
    3. update user method was added to auth service.py
    4. an schema is also needed
    the email containing the verification link will be sent to user upon succeessful registration
    5. so, edit the signup route

10. adding password reset feature
    (there is an update to role checker - we'll check if user is verified or not)
    1. we'll need 2 schemas, 1 to send email to request password recovery link (this could also just use Body parameter)
    the other to send new password and confirm password

11. setting up celery for background tasks
    (the first version will be trivial, then we'll move onto a more improved setup)
    1. pip install celery
    (notes: celery tasks are not async)
    (but since our code is async, we'll use asgiref to covert async code to sync)
    2. pip install asgiref
    (celery needs a message broker/task queue, this can be redis, rabbitmq, or amazon sqs)
    3. celery needs redis url to work with redis, so update config accordingly
    (adding redis_url we will need to delete redis host and port, and use this instead for redis)
    4. to run celery server:
    > celery -A src.sections.tasks worker --loglevel=INFO --pool=solo
    to check if celery works, run redis, start a shell, import test task and run it


12. Changing hashing algorithm from bcrypt to something else
    (bcrypt throws a warning and it's going on my nerves)




users:
    id = 1
    johndoe
    johndoe@email.com
    hello123 or test123



packages to install:
pytest, httpx



# @pytest_asyncio.fixture(scope='function')
# async def client() -> AsyncIterator[AsyncClient]:
#     async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
#         yield client


running async tests with pytest: sometimes runs them with more than one backend, this is why the number of tests are weird.
(run with pytest -v)